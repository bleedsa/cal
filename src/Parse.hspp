{-# LINE 1 "src/Parse.hs" #-}
# 0 "src/Parse.hs"
# 0 "<built-in>"
# 0 "<command-line>"
# 8 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4

# 17 "/usr/include/stdc-predef.h" 3 4



















# 45 "/usr/include/stdc-predef.h" 3 4

# 55 "/usr/include/stdc-predef.h" 3 4









# 8 "<command-line>" 2
# 1 "/home/skye/.ghcup/ghc/9.12.2/lib64/ghc-9.12.2/lib/../lib/x86_64-linux-ghc-9.12.2-16c3/rts-1.0.2/include/ghcversion.h" 1

















# 8 "<command-line>" 2
# 1 "/tmp/ghc54161_tmp_0/ghc_tmp_2.h" 1








































































































































































































































































# 8 "<command-line>" 2
# 1 "src/Parse.hs"
{-# LANGUAGE CPP #-}

module Parse where

import Text.Megaparsec
import Text.Megaparsec.Char
import Text.Printf
import Data.Text
import Data.Void

import Com

type Parser = Parsec Void Text

-- a variable type
data Type = Signed Int   -- x = number of bits
          | Unsigned Int -- x = number of bits
          | Void
          | Fun Sig
          deriving(Show, Eq)

-- a function signature.
-- 0: return type
-- 1: argument types
data Sig = Sig Type [Type]
         deriving(Show, Eq)

-- S expression stems
data S = I Int         -- integer
       | F Double      -- float
       | Str Text      -- string
       | V Text [Leaf] -- verb (Cons)
       | O Sig [Leaf]  -- lambda
       | T Type        -- typename
       | X Text        -- identifier
       deriving (Show, Eq)

-- a leaf is a position and an expression stem
data Leaf = Leaf P S
          deriving (Show, Eq)

getPos :: Parser P
getPos = do{ state <- getParserState
           ; let pos = pstateSourcePos $ statePosState state
           ; return $ P (sourceLine pos) (sourceColumn pos)
           }

spaces :: Parser ()
spaces = do { _ <- many space1
            ; pure ()
            }

int :: Parser Leaf
int = do{ p <- getPos
        ; h <- digitChar
        ; i <- many digitChar
        ; return $ Leaf p $ I $ read $ printf "%c%s" h i
        } <?> "integer"

flt :: Parser Leaf
flt = do{ p <- getPos
        ; h <- digitChar
        ; i' <- manyTill digitChar $ char '.' -- int
        ; let i = [h] ++ i'
        ; d <- many digitChar -- decimal 
        ; let i = if d == "" then i else printf "%s.%s" i d
        ; return $ Leaf p $ F $ read i
        }

num :: Parser Leaf
num = (try flt <|> int) <?> "number"

str :: Parser Leaf
str = do{ p <- getPos
        ; _ <- char '"'
        ; s <- (many $ anySingleBut '"') <?> "string"
        ; return $ Leaf p $ Str $ pack s
        } <?> "string"

verbStr :: Parser Text
verbStr = do{ h <- v
            ; t <- many v
            ; return $ pack $ h:t
            }
            where
                vs :: String
                vs = "~!@#$%^&*_+-=|:'<>?/.,\\|"
                v :: Parser Char
                v = oneOf vs

monad :: Parser Leaf
monad = do{ p <- getPos
          ; v <- verbStr
          ; x <- expr
          ; return $ Leaf p $ V v [x]
          }

dyad :: Parser Leaf
dyad = do{ p <- getPos
         ; x <- noun
         ; spaces
         ; v <- verbStr
         ; y <- expr
         ; return $ Leaf p $ V v [x, y]
         }

noun :: Parser Leaf
noun = (num <|> str) <?> "noun"

name :: Parser Text
name = do{ h <- letterChar
         ; t <- many $ alphaNumChar <|> char '_'
         ; return $ pack $ h:t
         }

typ :: Parser Leaf
typ = do{ p <- getPos
        ; n <- name
        ; t <- fromStr n
        ; return $ Leaf p $ T t
        }
        where
            fromStr :: Text -> Parser Type

            fromStr "u"#8 = pure $ Unsigned 8
            fromStr "i32" = pure $ Signed 32
            fromStr "i64" = pure $ Signed 64

expr :: Parser Leaf
expr = do{ spaces
         ; x <- (monad <|> try dyad <|> noun)
         ; spaces
         ; return x
         }

bind :: Parser Leaf
bind = do{ p <- getPos
         ; _ <- string $ pack "let"
         ; spaces
         ; n <- name
         ; spaces
         ; _ <- char ':'
         ; spaces
         ; t <- typ
         ; spaces
         ; _ <- char '='
         ; spaces
         ; x <- expr
         ; return $ Leaf p $ V "let" [Leaf p $ X n, t, x]
         }

exprs :: Parser [Leaf]
exprs = do{ x <- expr
          ; y <- observing rest
          ; return $ case y of
                         Left _ -> [x]
                         Right tail -> x:tail
          }
          where
              rest :: Parser [Leaf]
              rest = do{ char ';'
                       ; exprs
                       }

prs :: Text -> IO ()
prs x = putStrLn $ case parse exprs "" x of
                       Left e -> errorBundlePretty e
                       Right x -> show x
